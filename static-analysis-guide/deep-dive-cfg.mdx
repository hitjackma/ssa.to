
### 数据流中的支配关系

在接下来的内容中，我们重点将会讨论数据节点（变量）的支配问题。

数据流分析中，变量支配是一个非常重要的概念，他描述了变量之间的依赖关系，我们以 <InlineMath math="Dom(x, y)" /> 来表示变量 <InlineMath math="x" /> 支配变量 <InlineMath math="y" />。

<BlockMath math={`
对于变量\\ x\\ 和\\ y，如果：\\\\
Dom(x,\\ y)\\ \\iff\\ \\text{所有到达\\ y\\ 的路径都必须经过\\ x}
`} />

我们可以进一步形式化定义支配关系：

<BlockMath math={`
Dom(x,\\ y)\\ =\\ \\begin{cases}
true\\ &\\ \\text{若\\ x\\ 支配\\ y}\\ \\\\
false\\ &\\ \\text{其他情况}
\\end{cases}
`} />

其中：
- <InlineMath math="x" /> 是支配者(dominator)
- <InlineMath math="y" /> 是被支配者(dominee)

在深入思考，我们认为支配应该包含直接支配和间接支配两种，因此我们定义了三种支配关系：


1. **一般支配关系**

<BlockMath math={`
Dom(x, y) \\iff \\text{所有到达 y 的路径都必须经过 x}
`} />

2. **直接支配关系**

直接支配关系描述了两个变量之间最直接的依赖关系，没有任何中间变量。形式化定义如下：

<BlockMath math={`
iDom(x, y) \\iff \\begin{cases}
Dom(x, y) \\land \\\\
\\neg\\exists z(Dom(x, z) \\land Dom(z, y)) \\land \\\\
Connected(x, y)
\\end{cases}
`} />

其中：
- <InlineMath math="Dom(x, y)" /> 表示 x 支配 y
- <InlineMath math="\neg\exists z(Dom(x, z) \land Dom(z, y))" /> 表示不存在中间节点 z 同时被 x 支配且支配 y
- <InlineMath math="Connected(x, y)" /> 表示 x 和 y 在数据流图中直接相连

3. **间接支配关系**

<BlockMath math={`
indirectDom(x, y) \\iff \\begin{cases}
Dom(x, y) \\land \\\\
\\exists z(Dom(x, z) \\land Dom(z, y))
\\end{cases}
`} />



让我们通过一个具体的代码示例来理解上述的内容：

```go
a = input()      // 1
b = a + 1        // 2
if a > 0 {       // 3
    c = b + 2    // 4
} else {
    c = b - 2    // 5
}
d = c * 2        // 6
```

我们可以绘制这段代码的数据流图和支配关系：

```mermaid
graph LR
    A["a (1)"] -->|"直接支配"| B["b (2)"]
    B --> C1["c (4: b + 2)"]
    B --> C2["c (5: b - 2)"]
    C1 --> D["d (6)"]
    C2 --> D
    B -.->|"间接支配"| D
    A -.->|"间接支配"| D
    
    %% 使用不同的样式来突出支配关系
    classDef default fill:#f9f,stroke:#333,stroke-width:2px;
    linkStyle default stroke:#666,stroke-width:2px;

```

上述支配关系有点奇怪，因为 IF 分支的存在，导致有两个 `C` 节点。但是在 “变量” 的角度来说，我们应该合并 C，我们会只出来的支配关系应该如下：

```mermaid
graph LR
    A["a"] --> B["b"]
    B --> C["c"]
    C --> D["d"]
    
    classDef default fill:#bbf,stroke:#333,stroke-width:2px;
```

:::caution 注意

上述图示中，我们只保留了变量 C，这显然是看着非常别扭的，我们习惯了 SSA 思路之后，上述图显然是不合适的，我们后续就要解决这个问题

:::

接下来，我们再来讨论另一个案例，这是一个易错点。

```java
a = input()
b = input()
c = a + b
```

这种情况下，变量 `c` 同时依赖于 `a` 和 `b`，但是并不能说 `a` 支配 `c`，或者也不能说 `b` 支配 `c`。

`a` 和 `b` 仅仅是 `c` 的前继节点。


### 数据节点（变量）支配边界

在用户了解完支配问题之后，接下来我们提出一个问题，“一个数据节点的支配的范围有多大？”

要回答这个问题，我们需要定义一个概念叫支配边界。考虑任何离开块 B 的路径。最初路径上的块由 B 支配。最终到达一个不由 B 支配的块。除非路径返回到 B，否则之后的所有块都不受 B 支配。不被 B 支配的第一个块是重要的，因为它指示了 B 支配的块的范围，并使用有关 B 中的计算的信息指示了优化的限制。考虑到所有路径，拥有该特征的块的集合称为支配 B 的边界。

让我们首先给出支配边界的形式化定义：

<BlockMath math={`
DF(X) = \\{Y | \\exists Z \\in Dom(X) \\text{ such that } Y \\text{ is an immediate successor of } Z \\text{ and } X \\not\\in Dom(Y)\\}
`} />

其中：
- <InlineMath math={"DF(X)"} /> 表示节点X的支配边界
- <InlineMath math={"Dom(X)"} /> 表示被X支配的节点集合
- Y是X的支配边界中的一个节点
- Z是被X支配的某个节点
- Y是Z的直接后继节点
- X不支配Y

让我们用一个具体的例子来说明：

```mermaid
graph LR
  subgraph cluster [" "]
      style cluster fill:#E8E8E8,stroke:#CCCCCC
      5 --> 6
      6 --> 8
      6 --> 7
      7 --> 8
  end
  1 --> 2
  2 --> 3
  3 --> 4
  4 --> 13
  1 --> 5
  8 --> 13
  6 --> 4
  7 --> 12
  12 --> 13
  1 --> 9
  9 --> 10
  10 --> 12
  9 --> 11
  11 --> 12
```

我们给出图中各节点的支配边界分析表格：
| 节点 | 支配的节点集合 Dom(X) | 直接后继节点 | 支配边界 DF(X) |
|-----|-------------------|------------|-------------|
| 1 | \{1,2,3,4,5,6,7,8,9,10,11,12,13\} | \{2,5,9\} | ∅ |
| 2 | \{2,3\} | \{3\} | \{4\} |
| 3 | \{3\} | \{4\} | \{4\} |
| 4 | \{4\} | \{13\} | \{13\} |
| 5 | \{5,6,7,8\} | \{6\} | \{4,12,13\} |
| 6 | \{6,7,8\} | \{4,7,8\} | \{4,12,13\} |
| 7 | \{7\} | \{8,12\} | \{8,12\} |
| 8 | \{8\} | \{13\} | \{13\} |
| 9 | \{9,10,11\} | \{10,11\} | \{12\} |
| 10 | \{10\} | \{12\} | \{12\} |
| 11 | \{11\} | \{12\} | \{12\} |
| 12 | \{12\} | \{13\} | \{13\} |
| 13 | \{13\} | ∅ | ∅ |

给出支配边界计算算法的形式化表示：

<BlockMath math={`
\\begin{aligned}
DF_{local}(X) &= \\{Y \\in succ(X) \\mid X \\not\\in Dom(Y)\\} \\\\
DF_{up}(X) &= \\bigcup_{Z \\in DomTree_{children}(X)} \\{Y \\in DF(Z) \\mid X \\not\\in Dom(Y)\\} \\\\
DF(X) &= DF_{local}(X) \\cup DF_{up}(X)
\\end{aligned}
`} />

其中：
- <InlineMath math={"DF_{local}(X)"} /> 表示节点X的局部支配边界
- <InlineMath math={"DF_{up}(X)"} /> 表示从X的支配树子节点上传递来的支配边界
- <InlineMath math={"succ(X)"} /> 表示X的直接后继节点集合
- <InlineMath math={"DomTree_{children}(X)"} /> 表示X在支配树中的直接子节点集合

下面是计算支配边界的完整算法伪代码：

```javascript
// 计算所有节点的支配边界
function computeDominanceFrontiers(cfg) {
    let DF = new Map()  // 存储每个节点的支配边界
    
    // 按照支配树的后序遍历节点
    for (let X of postorderTraversal(cfg.domTree)) {
        DF.set(X, new Set())  // 初始化空集
        
        // 计算局部支配边界
        for (let Y of X.successors) {
            if (X.immediateDominator !== Y.immediateDominator) {
                DF.get(X).add(Y)
            }
        }
        
        // 计算来自子节点的支配边界
        for (let Z of X.domTreeChildren) {
            for (let Y of DF.get(Z)) {
                if (!dominates(X, Y) || X === Y) {
                    DF.get(X).add(Y)
                }
            }
        }
    }
    return DF
}

// 判断X是否支配Y
function dominates(X, Y) {
    return Y.dominators.has(X)
}
```
